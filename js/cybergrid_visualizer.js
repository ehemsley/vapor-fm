// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.CybergridVisualizer = (function() {
    function CybergridVisualizer(audioInitializer) {
      this.Update = bind(this.Update, this);
      this.Sun = bind(this.Sun, this);
      this.GridLines = bind(this.GridLines, this);
      var j, len, line, ref;
      this.audioInitializer = audioInitializer;
      this.timer = 0;
      this.scene = new THREE.Scene;
      this.camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.bloomParams = {
        strength: 3,
        strengthIncrease: 1,
        kernelSize: 12,
        sigma: 2.0,
        resolution: 512
      };
      this.noiseAmount = 0.1;
      this.ambientLight = new THREE.AmbientLight(0x404040);
      this.scene.add(this.ambientLight);
      this.pointLight = new THREE.PointLight(0xffffff, 1, 100);
      this.pointLight.position.set(10, 20, 20);
      this.scene.add(this.pointLight);
      this.skyBox = this.SkyBox();
      this.scene.add(this.skyBox);
      this.gridLines = this.GridLines(-60, -60, 60, 60, 3);
      ref = this.gridLines;
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        this.scene.add(line);
      }
      this.sun = this.Sun();
      this.scene.add(this.sun);
      this.sun.position.set(0, 5, -50);
      this.yRotationDirection = 1;
      this.beatDistortionEffect = true;
      this.camera.position.y = 5;
      this.camera.position.z = 20;
      return;
    }

    CybergridVisualizer.prototype.SkyBox = function() {
      var geometry, material, skybox;
      geometry = new THREE.BoxGeometry(500, 500, 500);
      material = new THREE.MeshBasicMaterial({
        color: 0x040404,
        side: THREE.BackSide
      });
      skybox = new THREE.Mesh(geometry, material);
      return skybox;
    };

    CybergridVisualizer.prototype.GridLines = function(left_x, bottom_y, right_x, top_y, spacing) {
      var color, j, k, l, line, lineGeometry, lineMaterial, lines, m, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, x, y;
      lines = [];
      color = new THREE.Color(0xffffff);
      for (y = j = ref = bottom_y, ref1 = top_y, ref2 = spacing; ref2 > 0 ? j <= ref1 : j >= ref1; y = j += ref2) {
        lineMaterial = new THREE.LineBasicMaterial({
          color: 0x0000ff,
          opacity: 0.8,
          transparent: true
        });
        lineGeometry = new THREE.Geometry();
        lineGeometry.vertices.push(new THREE.Vector3(left_x, 0, y));
        lineGeometry.vertices.push(new THREE.Vector3(right_x, 0, y));
        line = new THREE.Line(lineGeometry, lineMaterial);
        lines.push(line);
      }
      for (x = k = ref3 = left_x, ref4 = right_x, ref5 = spacing; ref5 > 0 ? k <= ref4 : k >= ref4; x = k += ref5) {
        lineMaterial = new THREE.LineBasicMaterial({
          color: 0x0000ff,
          opacity: 0.8,
          transparent: true
        });
        lineGeometry = new THREE.Geometry();
        lineGeometry.vertices.push(new THREE.Vector3(x, 0, bottom_y));
        lineGeometry.vertices.push(new THREE.Vector3(x, 0, top_y));
        line = new THREE.Line(lineGeometry, lineMaterial);
        lines.push(line);
      }
      for (y = l = ref6 = bottom_y, ref7 = top_y, ref8 = spacing; ref8 > 0 ? l <= ref7 : l >= ref7; y = l += ref8) {
        lineMaterial = new THREE.LineBasicMaterial({
          color: 0x0000ff,
          opacity: 0.8,
          transparent: true
        });
        lineGeometry = new THREE.Geometry();
        lineGeometry.vertices.push(new THREE.Vector3(left_x, 10, y));
        lineGeometry.vertices.push(new THREE.Vector3(right_x, 10, y));
        line = new THREE.Line(lineGeometry, lineMaterial);
        lines.push(line);
      }
      for (x = m = ref9 = left_x, ref10 = right_x, ref11 = spacing; ref11 > 0 ? m <= ref10 : m >= ref10; x = m += ref11) {
        lineMaterial = new THREE.LineBasicMaterial({
          color: 0x0000ff,
          opacity: 0.8,
          transparent: true
        });
        lineGeometry = new THREE.Geometry();
        lineGeometry.vertices.push(new THREE.Vector3(x, 10, bottom_y));
        lineGeometry.vertices.push(new THREE.Vector3(x, 10, top_y));
        line = new THREE.Line(lineGeometry, lineMaterial);
        lines.push(line);
      }
      return lines;
    };

    CybergridVisualizer.prototype.Sun = function() {
      var geometry, material, sun;
      geometry = new THREE.CylinderGeometry(0, 5.5, 6, 4, false);
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 1.0,
        transparent: true
      });
      sun = new THREE.Mesh(geometry, material);
      return sun;
    };

    CybergridVisualizer.prototype.Update = function(deltaTime) {
      var i, j, k, len, line, randomLine, ref;
      if (deltaTime != null) {
        this.timer += deltaTime;
        this.sun.rotation.y += deltaTime * this.yRotationDirection;
      }
      ref = this.gridLines;
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        if (line.material.opacity > 0.5) {
          line.material.opacity = Math.max(line.material.opacity - 0.01, 0.5);
          line.material.needsUpdate = true;
        }
      }
      if (this.audioInitializer.beatdetect.isSnare()) {
        for (i = k = 0; k <= 29; i = ++k) {
          randomLine = this.gridLines[this.RandomInt(0, this.gridLines.length - 1)];
          randomLine.material.opacity = 1.0;
          randomLine.material.needsUpdate = true;
        }
      }
      if (this.audioInitializer.beatdetect.isKick()) {
        this.yRotationDirection = Math.random() < 0.5 ? -1 : 1;
        this.sun.scale.set(1.2, 1.2, 1.2);
      } else {
        this.sun.scale.x = Math.max(this.sun.scale.x - 0.01, 1);
        this.sun.scale.y = Math.max(this.sun.scale.y - 0.01, 1);
        this.sun.scale.z = Math.max(this.sun.scale.z - 0.01, 1);
      }
    };

    CybergridVisualizer.prototype.HandleKeyDownInput = function(keyCode) {};

    CybergridVisualizer.prototype.HandleKeyUpInput = function(keyCode) {};

    CybergridVisualizer.prototype.RandomInt = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    CybergridVisualizer.prototype.Activate = function() {};

    return CybergridVisualizer;

  })();

}).call(this);
