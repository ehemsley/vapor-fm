// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Visualizer = (function() {
    function Visualizer(audioInitializer) {
      this.OnResize = bind(this.OnResize, this);
      this.Render = bind(this.Render, this);
      this.RenderProcess = bind(this.RenderProcess, this);
      var i;
      this.audioInitializer = audioInitializer;
      this.visualizerElement = $('#visualizer');
      this.timer = 0;
      this.xRotationDirection = 1;
      this.yRotationDirection = -1;
      this.scene = new THREE.Scene;
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.renderer = new THREE.WebGLRenderer;
      this.renderer.setClearColor(0x07020a);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.visualizerElement.append(this.renderer.domElement);
      this.cube = this.Cube();
      this.lineBoxes = this.LineBoxes();
      this.scene.add(this.cube);
      i = 0;
      while (i < this.lineBoxes.length) {
        this.scene.add(this.lineBoxes[i]);
        i++;
      }
      this.camera.position.z = 5;
      this.RenderProcess();
      return;
    }

    Visualizer.prototype.Cube = function() {
      var cube, geometry, material;
      geometry = new THREE.BoxGeometry(3, 3, 3);
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: false
      });
      cube = new THREE.Mesh(geometry, material);
      return cube;
    };

    Visualizer.prototype.LineBoxes = function() {
      var i, lineBox, lineBoxGeometry, lineBoxes, lineMaterial;
      lineMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff
      });
      lineBoxes = [];
      i = 0;
      while (i < 20) {
        lineBoxGeometry = new THREE.Geometry;
        lineBoxGeometry.vertices.push(new THREE.Vector3(-20, 10, -10));
        lineBoxGeometry.vertices.push(new THREE.Vector3(20, 10, -10));
        lineBoxGeometry.vertices.push(new THREE.Vector3(20, -10, -10));
        lineBoxGeometry.vertices.push(new THREE.Vector3(-20, -10, -10));
        lineBoxGeometry.vertices.push(new THREE.Vector3(-20, 10, -10));
        lineBox = new THREE.Line(lineBoxGeometry, lineMaterial);
        lineBoxes[i] = lineBox;
        i++;
      }
      return lineBoxes;
    };

    Visualizer.prototype.RenderProcess = function() {
      var bloomPass, film, horizontalBlur, renderPass, renderTargetCube, renderTargetGlow, renderTargetParameters, verticalBlur, vignette;
      renderTargetParameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat,
        stencilBuffer: false
      };
      renderTargetCube = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetParameters);
      this.cubeComposer = new THREE.EffectComposer(this.renderer, renderTargetCube);
      renderPass = new THREE.RenderPass(this.scene, this.camera);
      this.cubeComposer.addPass(renderPass);
      renderTargetGlow = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, renderTargetParameters);
      this.glowComposer = new THREE.EffectComposer(this.renderer, renderTargetGlow);
      horizontalBlur = new THREE.ShaderPass(THREE.HorizontalBlurShader);
      horizontalBlur.uniforms['h'].value = 2.0 / window.innerWidth;
      verticalBlur = new THREE.ShaderPass(THREE.VerticalBlurShader);
      verticalBlur.uniforms['v'].value = 2.0 / window.innerHeight;
      this.glowComposer.addPass(renderPass);
      this.glowComposer.addPass(horizontalBlur);
      this.glowComposer.addPass(verticalBlur);
      this.glowComposer.addPass(horizontalBlur);
      this.glowComposer.addPass(verticalBlur);
      this.blendPass = new THREE.ShaderPass(THREE.AdditiveBlendShader);
      this.blendPass.uniforms['tBase'].value = this.cubeComposer.renderTarget1;
      this.blendPass.uniforms['tAdd'].value = this.glowComposer.renderTarget1;
      this.blendPass.uniforms['amount'].value = 2.0;
      this.blendComposer = new THREE.EffectComposer(this.renderer);
      this.blendComposer.addPass(this.blendPass);
      bloomPass = new THREE.BloomPass(3, 12, 2.0, 512);
      this.blendComposer.addPass(bloomPass);
      this.badTV = new THREE.ShaderPass(THREE.BadTVShader);
      this.badTV.uniforms['distortion'].value = 1.0;
      this.badTV.uniforms['distortion2'].value = 1.0;
      this.badTV.uniforms['speed'].value = 0.1;
      this.badTV.uniforms['rollSpeed'].value = 0.0;
      this.blendComposer.addPass(this.badTV);
      this.rgbEffect = new THREE.ShaderPass(THREE.RGBShiftShader);
      this.rgbEffect.uniforms['amount'].value = 0.0015;
      this.rgbEffect.uniforms['angle'].value = 0;
      this.blendComposer.addPass(this.rgbEffect);
      film = new THREE.ShaderPass(THREE.FilmShader);
      film.uniforms['sCount'].value = 800;
      film.uniforms['sIntensity'].value = 0.9;
      film.uniforms['nIntensity'].value = 0.4;
      film.uniforms['grayscale'].value = 0;
      this.blendComposer.addPass(film);
      vignette = new THREE.ShaderPass(THREE.VignetteShader);
      vignette.uniforms['darkness'].value = 1;
      vignette.uniforms['offset'].value = 1.1;
      vignette.renderToScreen = true;
      this.blendComposer.addPass(vignette);
    };

    Visualizer.prototype.Render = function() {
      var i, rotationAddition, scaleValue;
      requestAnimationFrame(this.Render);
      this.timer += 0.01;
      this.rgbEffect.uniforms['amount'].value = Math.sin(this.timer * 2) * 0.01;
      this.badTV.uniforms['time'].value = this.timer;
      this.audioInitializer.analyser.getByteFrequencyData(this.audioInitializer.frequencyData);
      this.audioInitializer.analyser.getFloatTimeDomainData(this.audioInitializer.floats);
      rotationAddition = this.audioInitializer.GetAverageVolume(this.audioInitializer.frequencyData) / 2000;
      this.cube.rotation.x += (0.01 + rotationAddition) * this.xRotationDirection;
      this.cube.rotation.y += (0.01 + rotationAddition) * this.yRotationDirection;
      this.audioInitializer.beatdetect.detect(this.audioInitializer.floats);
      scaleValue = 1.1;
      if (this.audioInitializer.beatdetect.isKick()) {
        this.cube.scale.x = scaleValue;
        this.cube.scale.y = scaleValue;
        this.cube.scale.z = scaleValue;
        this.badTV.uniforms['distortion'].value = 5 * Math.random();
        this.badTV.uniforms['distortion2'].value = 5 * Math.random();
        if (Math.random() < 0.05) {
          this.badTV.uniforms['rollSpeed'].value = (Math.random() < 0.5 ? -1 : 1) * this.audioInitializer.GetAverageVolume(this.audioInitializer.frequencyData) / 5000;
        }
        this.xRotationDirection = Math.random() < 0.5 ? -1 : 1;
        this.yRotationDirection = Math.random() < 0.5 ? -1 : 1;
      } else {
        this.cube.scale.x = Math.max(this.cube.scale.x - 0.001, 1);
        this.cube.scale.y = Math.max(this.cube.scale.y - 0.001, 1);
        this.cube.scale.z = Math.max(this.cube.scale.z - 0.001, 1);
        this.badTV.uniforms['distortion'].value = Math.max(this.badTV.uniforms['distortion'].value - 0.1, 1);
        this.badTV.uniforms['distortion2'].value = Math.max(this.badTV.uniforms['distortion2'].value - 0.1, 1);
        if (this.badTV.uniforms['rollSpeed'].value > 0) {
          this.badTV.uniforms['rollSpeed'].value = Math.max(this.badTV.uniforms['rollSpeed'].value - 0.001, 0);
        } else {
          this.badTV.uniforms['rollSpeed'].value = Math.min(this.badTV.uniforms['rollSpeed'].value + 0.001, 0);
        }
      }
      i = 0;
      while (i < this.lineBoxes.length) {
        this.lineBoxes[i].scale.x = ((this.timer + (i * 0.5)) * 0.2) % 1.5;
        this.lineBoxes[i].scale.y = ((this.timer + (i * 0.5)) * 0.2) % 1.5;
        i++;
      }
      this.cubeComposer.render(0.1);
      this.glowComposer.render(0.1);
      this.blendComposer.render(0.1);
    };

    Visualizer.prototype.OnResize = function() {
      var renderH, renderW;
      renderW = window.innerWidth;
      renderH = window.innerHeight;
      this.camera.aspect = renderW / renderH;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(renderW, renderH);
      this.renderer.domElement.width = renderW;
      this.renderer.domElement.height = renderH;
    };

    return Visualizer;

  })();

}).call(this);
